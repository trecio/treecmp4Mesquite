/* * TranspositionMetric.java * * Created on 1 kwie 2007, 11:42 * * To change this template, choose Tools | Template Manager * and open the template in the editor. */package treecmp.metric;import pal.tree.*;import java.util.*;import pal.misc.IdGroup;import treecmp.*;/** * * @author VOX */public class TranspositionMetric {    /** Creates a new instance of TranspositionMetric */    public TranspositionMetric() {    }    public static HashMap<Integer, TreeSet<Integer>> getMatchingRepesentation(Tree tree, IdGroup id) {        HashMap<Integer, TreeSet<Integer>> rep = new HashMap<Integer, TreeSet<Integer>>();        SimpleNodeExt node, parent, child;        SimpleNodeExt root = new SimpleNodeExt(tree.getRoot());        int nr, i, key;        int height, children_nr;        SimpleTreeExt treeExt = new SimpleTreeExt(root);        TreeMap<Integer, ArrayList<Integer>> levelMap = new TreeMap<Integer, ArrayList<Integer>>();        ArrayList<Integer> list;        TreeSet<Integer> children_set;        //  levelMap.put()        int size = treeExt.getInternalNodeCount() + treeExt.getExternalNodeCount();        for (i = 1; i <= size; i++) {            node = (SimpleNodeExt) treeExt.findNode(i);            height = NodeUtils.getMaxNodeDepth(node) - 1;            node.level = height;            node.label = 0;            list = levelMap.get(height);            if (list == null) {                list = new ArrayList<Integer>();                list.add(i);                levelMap.put(height, list);            } else {                list.add(i);            }        }        size = treeExt.getExternalNodeCount();        for (i = 0; i < size; i++) {            node = (SimpleNodeExt) treeExt.getExternalNode(i);            //node=(SimpleNodeExt)treeExt.getRoot();            nr = id.whichIdNumber(node.getIdentifier().getName());            node.label = nr + 1;        }        i = size;        Set<Integer> set_it = levelMap.keySet();        Iterator<Integer> iter = set_it.iterator();        while (iter.hasNext()) {            key = iter.next();            ArrayList<Integer> list2 = levelMap.get(key);            Collections.sort(list2, new TComparator(treeExt));            Iterator<Integer> iter2 = list2.iterator();            while (iter2.hasNext()) {                nr = iter2.next();                node = (SimpleNodeExt) treeExt.findNode(nr);                parent = (SimpleNodeExt) node.getParent();                if (parent != null) {                    if (parent.label == 0 && parent.level == (key + 1)) {                        i++;                        parent.label = i;                    }                }            }        }        //konstruujemy matching reprezentation        //dla kazdego wezla wewnetrzngo zapamietujemy etykiety jego dzieci        size = treeExt.getInternalNodeCount();        for (i = 0; i < size; i++) {            node = (SimpleNodeExt) treeExt.getInternalNode(i);            children_nr = node.getChildCount();            children_set = new TreeSet<Integer>();            children_set.clear();            for (int j = 0; j < children_nr; j++) {                child = (SimpleNodeExt) node.getChild(j);                children_set.add(child.label);            }            rep.put(i, children_set);        }        return rep;    }    public static String getStringFromMatching(HashMap<Integer, TreeSet<Integer>> matching) {        String str = new String("Matching:");        Set<Integer> key_set = matching.keySet();        for (Integer key : key_set) {            TreeSet<Integer> match_part = matching.get(key);            for (Integer label : match_part) {                str = str.concat(" " + label.toString());            }            str = str.concat("|");        }        return str;    }    private static int getMatchingCount(HashMap<Integer, TreeSet<Integer>> matching) {        Set<Integer> key_set = matching.keySet();        int size = 0;        for (Integer key : key_set) {            TreeSet<Integer> match_part = matching.get(key);            size += match_part.size();        }        return size;    }    public static Graph getGraphFromMatching(HashMap<Integer, TreeSet<Integer>> matching) {        int size = getMatchingCount(matching);        Graph graph = new Graph(size);        Set<Integer> key_set = matching.keySet();        int first = 0;        int previous = 0;        int actual = 0;        for (Integer key : key_set) {            TreeSet<Integer> match_part = matching.get(key);            first = 0;            previous = 0;            actual = 0;            for (Integer label : match_part) {                //zapamietujemy perwszy wierzcholek                if (label == match_part.first()) {                    first = label.intValue();                    previous = first;                } else {                    actual = label.intValue();                    graph.edges[previous][actual].isPresent = true;                    graph.edges[previous][actual].begin = previous;                    graph.edges[previous][actual].end = actual;                    previous = actual;                }            }            graph.edges[match_part.last().intValue()][first].isPresent = true;            graph.edges[match_part.last().intValue()][first].begin = match_part.last().intValue();            graph.edges[match_part.last().intValue()][first].end = first;        }        return graph;    }    public static double getTranspositionDistance(Tree tree1, Tree tree2) {        int N, d, A;        double dist;        //obliczmy matchingi        HashMap<Integer, TreeSet<Integer>> match1 = getMatchingRepesentation(tree1, TreeUtils.getLeafIdGroup(tree1));        HashMap<Integer, TreeSet<Integer>> match2 = getMatchingRepesentation(tree2, TreeUtils.getLeafIdGroup(tree1));        /*        match1.clear();        TreeSet<Integer> ob =new TreeSet<Integer>();        ob.add(1);        ob.add(5);        ob.add(7);        ob.add(9);        match1.put(0,ob);        ob =new TreeSet<Integer>();        ob.add(4);        ob.add(6);        ob.add(10);        match1.put(1,ob);        ob =new TreeSet<Integer>();        ob.add(2);        ob.add(11);        match1.put(2,ob);        ob =new TreeSet<Integer>();        ob.add(8);        ob.add(13);        match1.put(3,ob);        ob =new TreeSet<Integer>();        ob.add(3);        ob.add(12);        ob.add(14);        match1.put(4,ob);         //match2        ob =new TreeSet<Integer>();        ob.add(4);        ob.add(6);        match2.put(0,ob);         ob =new TreeSet<Integer>();        ob.add(7);        ob.add(5);        match2.put(1,ob);         ob =new TreeSet<Integer>();        ob.add(1);        ob.add(12);        match2.put(2,ob);         ob =new TreeSet<Integer>();        ob.add(10);        ob.add(11);        match2.put(3,ob);         ob =new TreeSet<Integer>();        ob.add(9);        ob.add(14);        match2.put(4,ob);         ob =new TreeSet<Integer>();        ob.add(13);        ob.add(15);        match2.put(5,ob);         ob =new TreeSet<Integer>();        ob.add(2);        ob.add(16);        match2.put(6,ob);         ob =new TreeSet<Integer>();        ob.add(8);        ob.add(17);        match2.put(7,ob);         ob =new TreeSet<Integer>();        ob.add(3);        ob.add(18);        match2.put(8,ob);          */        Graph graph1 = getGraphFromMatching(match1);        Graph graph2 = getGraphFromMatching(match2);        Vector<Integer> vec;        d = 0;        Graph sumGraph = Graph.getSumGraph(graph1, graph2.getInvertGraph());        sumGraph.printGraph();        N = sumGraph.size;        int i;        while (!(vec = sumGraph.getUnbalancedNodes()).isEmpty()) {            System.out.println("N=" + N + " d=" + d);            for (Integer ii : vec) {                i = ii.intValue();                //first rule for red color                Vector<Integer> next = sumGraph.getNextVertexByColor(i, Edge.RED);                Vector<Integer> prev = sumGraph.getPreviousVertexByColor(i, Edge.RED);                for (Integer i0 : prev) {                    for (Integer i1 : next) {                        int i_0 = i0.intValue();                        int i_1 = i1.intValue();                        if (i_0 != i_1) {                            //removing edges                            sumGraph.edges[i_0][i].isRed = false;                            sumGraph.setNotPresentIfNotColored(i_0, i);                            sumGraph.edges[i][i_1].isRed = false;                            sumGraph.setNotPresentIfNotColored(i, i_1);                            //adding red edge                            sumGraph.edges[i_0][i_1].isPresent = true;                            sumGraph.edges[i_0][i_1].isRed = true;                            sumGraph.edges[i_0][i_1].begin = i_0;                            sumGraph.edges[i_0][i_1].end = i_1;                            d = d + 1;                            N = N - 1;                        }                    }                }                //first rule for blue color                next = sumGraph.getNextVertexByColor(i, Edge.BLUE);                prev = sumGraph.getPreviousVertexByColor(i, Edge.BLUE);                for (Integer i0 : prev) {                    for (Integer i1 : next) {                        int i_0 = i0.intValue();                        int i_1 = i1.intValue();                        if (i_0 != i_1) {                            //removing edges                            sumGraph.edges[i_0][i].isBlue = false;                            sumGraph.setNotPresentIfNotColored(i_0, i);                            sumGraph.edges[i][i_1].isBlue = false;                            sumGraph.setNotPresentIfNotColored(i, i_1);                            //adding red edge                            sumGraph.edges[i_0][i_1].isPresent = true;                            sumGraph.edges[i_0][i_1].isBlue = true;                            sumGraph.edges[i_0][i_1].begin = i_0;                            sumGraph.edges[i_0][i_1].end = i_1;                            d = d + 1;                            N = N - 1;                        }                    }                }                //second rule for red color                next = sumGraph.getNextVertexByColor(i, Edge.RED);                prev = sumGraph.getPreviousVertexByColor(i, Edge.RED);                for (Integer i0 : prev) {                    for (Integer i1 : next) {                        int i_0 = i0.intValue();                        int i_1 = i1.intValue();                        if (i_0 == i_1) {                            //removing edges                            sumGraph.edges[i_0][i].isRed = false;                            sumGraph.setNotPresentIfNotColored(i_0, i);                            sumGraph.edges[i][i_1].isRed = false;                            sumGraph.setNotPresentIfNotColored(i, i_1);                            d = d + 1;                            if (!vec.contains(new Integer(i_1))) {                                N = N - 1;                            } else {                                N = N - 2;                            }                        }                    }                }                //second rule for blue color                next = sumGraph.getNextVertexByColor(i, Edge.BLUE);                prev = sumGraph.getPreviousVertexByColor(i, Edge.BLUE);                for (Integer i0 : prev) {                    for (Integer i1 : next) {                        int i_0 = i0.intValue();                        int i_1 = i1.intValue();                        if (i_0 == i_1) {                            //removing edges                            sumGraph.edges[i_0][i].isBlue = false;                            sumGraph.setNotPresentIfNotColored(i_0, i);                            sumGraph.edges[i][i_1].isBlue = false;                            sumGraph.setNotPresentIfNotColored(i, i_1);                            d = d + 1;                            if (!vec.contains(new Integer(i_1))) {                                N = N - 1;                            } else {                                N = N - 2;                            }                        }                    }                }            }        }        A = sumGraph.getNumOfAlternatingCycles();        //while(sumGraph.)        dist = (d + N - A) / 2.0;        return dist;    }}