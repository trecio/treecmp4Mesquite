/* * Graph.java * * Created on 23 kwie 2007, 17:58 * * To change this template, choose Tools | Template Manager * and open the template in the editor. */package treecmp;import java.util.Vector;/** * * @author Damian */public class Graph {      /** Creates a new instance of Graph */    public Edge[][] edges;    public int size;      public Graph() {    }        public Graph(int size) {     this.size=size;     this.edges=new Edge[size+1][size+1];     for(int i=1;i<=size;i++)     {        for(int j=1;j<=size;j++)        {            this.edges[i][j]=new Edge(false);        }     }   }    public Edge getEdge(int i,int j)    {        if(i<=this.size && j<=this.size)        {         return this.edges[i][j];           }        else return null;    }public Graph getInvertGraph(){    Graph invgraph=new Graph(this.size);    for(int i=1;i<=size;i++)    {        for(int j=1;j<=size;j++)        {           if(this.edges[i][j].isPresent==true)             {                invgraph.edges[j][i].isPresent=true;                invgraph.edges[j][i].begin=j;                invgraph.edges[j][i].end=i;                  }                    }    }    return invgraph;}public static Graph getSumGraph(Graph graphRed,Graph graphBlue){int size,sizeRed,sizeBlue;sizeRed=graphRed.size;sizeBlue=graphBlue.size;if(sizeRed>sizeBlue) size=sizeRed;else size=sizeBlue;            Graph sumGraph=new Graph(size);    for(int i=1;i<=size;i++)    {        for(int j=1;j<=size;j++)        {                        if(i<=sizeRed && j<=sizeRed)            {                if(graphRed.getEdge(i,j).isPresent==true)                {                    sumGraph.getEdge(i,j).isRed=true;                    sumGraph.getEdge(i,j).isPresent=true;                    sumGraph.getEdge(i,j).begin=i;                    sumGraph.getEdge(i,j).end=j;                }                            }                        if(i<=sizeBlue && j<=sizeBlue)            {                if(graphBlue.getEdge(i,j).isPresent==true)                {                    sumGraph.getEdge(i,j).isBlue=true;                    sumGraph.getEdge(i,j).isPresent=true;                    sumGraph.getEdge(i,j).begin=i;                    sumGraph.getEdge(i,j).end=j;                }                            }                              }                    }       return sumGraph;}private boolean isRedIsolated(int v){    for(int i=1;i<=this.size;i++)    {        if(this.getEdge(v,i).isRed==true) return false;        if(this.getEdge(i,v).isRed==true) return false;    }        return true;    }private boolean isBlueIsolated(int v){    for(int i=1;i<=this.size;i++)    {        if(this.getEdge(v,i).isBlue==true) return false;        if(this.getEdge(i,v).isBlue==true) return false;    }        return true;    }public Vector <Integer> getUnbalancedNodes(){    Vector<Integer> vec=new Vector<Integer>();    for(int i=1;i<=this.size;i++)    {       if((this.isBlueIsolated(i)&& (!this.isRedIsolated(i))) || (!(this.isBlueIsolated(i))&& this.isRedIsolated(i)))       {           vec.add(new Integer(i)) ;       }    }             return vec;   }public boolean isUnbalancedNode(int i){     if((this.isBlueIsolated(i)&& (!this.isRedIsolated(i))) || (!(this.isBlueIsolated(i))&& this.isRedIsolated(i))) return true;     else return false;        }public void setNotPresentIfNotColored(int i,int j){        if(this.edges[i][j].isBlue==false && this.edges[i][j].isRed==false) this.edges[i][j].isPresent=false;        }private Edge getUntraversedEdge(){        for(int i=1;i<=this.size;i++)    {                for(int j=1;j<=this.size;j++)        {                        Edge edge=this.getEdge(i,j);            if(edge.isPresent==true)            {                if((edge.isRed==true && edge.inRedCycle==false)||(edge.isBlue==true && edge.inBlueCycle==false)) return edge;                            }             }            }        return null;}public void printGraph(){    for(int i=1;i<=this.size;i++)    {                for(int j=1;j<=this.size;j++)        {                        Edge edge=this.getEdge(i,j);            if(edge.isPresent==true)            {                if(edge.isRed==true)   System.out.println("Edge ("+i+","+j+") Red");                if(edge.isBlue==true)   System.out.println("Edge ("+i+","+j+") Blue");            }            }    }  }private void traverseCycleFromEdge(Edge edge){    int begin=edge.begin;    int end=edge.end;    int nextColor=0;    int i;    //sprawdzamy kolor        if(edge.isRed==true && edge.inRedCycle==false) nextColor=Edge.BLUE;    if(edge.isBlue==true && edge.inBlueCycle==false) nextColor=Edge.RED;    edge.traverseEdge(1-nextColor);        Edge e=edge;    System.out.print(begin);    System.out.print("-");    System.out.print(e.end);    while(e.end!=begin)    {                //szukamy krawedzi o odpowiedznim kolorze nexcolor        i=e.end;               for(int j=1; j<=this.size;j++)        {            if(j!=i)            {                             e=this.getEdge(i,j);                if(e.isPresent==true && e.isColored(nextColor) && !e.isEdegeTraversed(nextColor))                {                 System.out.print("-");                 System.out.print(j);                 e.traverseEdge(nextColor);                 nextColor=1-nextColor;                 break;                }            }                    }            }        System.out.print("\n");    }public Vector<Integer> getNextVertexByColor(int base,int color){    Vector<Integer> vec=new Vector<Integer>();         for(int i=1;i<=this.size;i++)    {        if(this.edges[base][i].isColored(color)) vec.add(new Integer(i));        }    return vec;}public Vector<Integer> getPreviousVertexByColor(int base,int color){    Vector<Integer> vec=new Vector<Integer>();         for(int i=1;i<=this.size;i++)    {        if(this.edges[i][base].isColored(color)) vec.add(new Integer(i));        }    return vec;}public int getNumOfAlternatingCycles(){    Edge edge;    int A=0;    while ((edge=this.getUntraversedEdge())!=null)    {        A++;        this.traverseCycleFromEdge(edge);    }    return A;}}